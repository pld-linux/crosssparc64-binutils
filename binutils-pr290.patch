2004-07-29  H.J. Lu  <hongjiu.lu@intel.com>
	    Nick Clifton  <nickc@redhat.com>

	PR 290
	* bfd.c (_bfd_default_error_handler): Make it global.

	* elf-bfd.h (elf_backend_data): Add link_order_error_handler.

	* elf.c (assign_section_numbers): Cope gracefully with sections
	which have SHF_LINK_ORDER set but no sh_link set up.
	* elflink.c (elf_get_linked_section_vma): Likewise.

	* elfxx-ia64.c (elf_backend_link_order_error_handler): New. Set
	it to NULL.

	* elfxx-target.h (elf_backend_link_order_error_handler): New.
	Set it to _bfd_default_error_handler.
	(elfNN_bed): Add elf_backend_link_order_error_handler.

	* libbfd-in.h (_bfd_default_error_handler): New.

	* libbfd.h: Regenerated.

--- bfd/bfd.c.order	2004-07-03 10:00:44.000000000 -0700
+++ bfd/bfd.c	2004-07-29 09:52:39.000000000 -0700
@@ -408,7 +408,7 @@ static const char *_bfd_error_program_na
 
 /* This is the default routine to handle BFD error messages.  */
 
-static void
+void
 _bfd_default_error_handler (const char *s, ...)
 {
   va_list p;
--- bfd/elf-bfd.h.order	2004-07-28 10:50:36.000000000 -0700
+++ bfd/elf-bfd.h	2004-07-29 09:11:12.000000000 -0700
@@ -925,6 +925,9 @@ struct elf_backend_data
      see elf.c.  */
   bfd_vma (*plt_sym_val) (bfd_vma, const asection *, const arelent *);
 
+  /* Used to handle bad SHF_LINK_ORDER input.  */
+  bfd_error_handler_type link_order_error_handler;
+
   /* Name of the PLT relocation section.  */
   const char *relplt_name;
 
--- bfd/elf.c.order	2004-07-28 10:58:13.000000000 -0700
+++ bfd/elf.c	2004-07-29 10:08:01.000000000 -0700
@@ -2885,10 +2885,32 @@ assign_section_numbers (bfd *abfd)
 		      int elfsec
 			= _bfd_elf_section_from_bfd_section (s->owner, s);
 		      elfsec = elf_shdrp[elfsec]->sh_link;
-		      BFD_ASSERT (elfsec != 0);
-		      s = elf_shdrp[elfsec]->bfd_section->output_section;
-		      BFD_ASSERT (s != NULL);
-		      d->this_hdr.sh_link = elf_section_data (s)->this_idx;
+		      /* PR 290:
+			 The Intel C compiler generates SHT_IA_64_UNWIND with
+			 SHF_LINK_ORDER.  But it doesn't set theh sh_link or
+			 sh_info fields.  Hence we could get the situation
+		         where elfsec is 0.  */
+		      if (elfsec == 0)
+			{
+			  const struct elf_backend_data *bed
+			    = get_elf_backend_data (abfd);
+			  if (bed->link_order_error_handler)
+			    {
+			      char *name = bfd_get_section_ident (s);
+			      bed->link_order_error_handler
+				(_("%s: warning: sh_link not set for section `%s'"),
+				 bfd_archive_filename (abfd),
+				 name ? name : s->name);
+			      if (name)
+				free (name);
+			    }
+			}
+		      else
+			{
+			  s = elf_shdrp[elfsec]->bfd_section->output_section;
+			  BFD_ASSERT (s != NULL);
+			  d->this_hdr.sh_link = elf_section_data (s)->this_idx;
+			}
 		      break;
 		    }
 		}
--- bfd/elflink.c.order	2004-07-28 10:50:39.000000000 -0700
+++ bfd/elflink.c	2004-07-29 10:08:03.000000000 -0700
@@ -7220,8 +7220,32 @@ elf_get_linked_section_vma (struct bfd_l
   elf_shdrp = elf_elfsections (s->owner);
   elfsec = _bfd_elf_section_from_bfd_section (s->owner, s);
   elfsec = elf_shdrp[elfsec]->sh_link;
-  s = elf_shdrp[elfsec]->bfd_section;
-  return s->output_section->vma + s->output_offset;
+  /* PR 290:
+     The Intel C compiler generates SHT_IA_64_UNWIND with
+     SHF_LINK_ORDER.  But it doesn't set theh sh_link or
+     sh_info fields.  Hence we could get the situation
+     where elfsec is 0.  */
+  if (elfsec == 0)
+    {
+      const struct elf_backend_data *bed
+	= get_elf_backend_data (s->owner);
+      if (bed->link_order_error_handler)
+	{
+	  char *name = bfd_get_section_ident (s);
+	  bed->link_order_error_handler
+	    (_("%s: warning: sh_link not set for section `%s'"),
+	     bfd_archive_filename (s->owner),
+	     name ? name : s->name);
+	  if (name)
+	    free (name);
+	}
+      return 0;
+    }
+  else
+    {
+      s = elf_shdrp[elfsec]->bfd_section;
+      return s->output_section->vma + s->output_offset;
+    }
 }
 
 
--- bfd/elfxx-ia64.c.order	2004-07-28 10:50:39.000000000 -0700
+++ bfd/elfxx-ia64.c	2004-07-29 10:12:45.000000000 -0700
@@ -4987,6 +4987,13 @@ elfNN_hpux_backend_symbol_processing (bf
 #define elf_backend_rela_normal		1
 #define elf_backend_special_sections	elfNN_ia64_special_sections
 
+/* FIXME: PR 290: The Intel C compiler generates SHT_IA_64_UNWIND with
+   SHF_LINK_ORDER. But it doesn't set theh sh_link or sh_info fields.
+   We don't want to flood users with so many error messages. We turn
+   off the warning for now. It will be turned on later when the Intel
+   compiler is fixed.   */
+#define elf_backend_link_order_error_handler NULL
+
 #include "elfNN-target.h"
 
 /* HPUX-specific vectors.  */
--- bfd/elfxx-target.h.order	2004-07-21 19:49:34.000000000 -0700
+++ bfd/elfxx-target.h	2004-07-29 09:53:30.000000000 -0700
@@ -491,6 +491,10 @@
 #define elf_backend_sign_extend_vma 0
 #endif
 
+#ifndef elf_backend_link_order_error_handler
+#define elf_backend_link_order_error_handler _bfd_default_error_handler
+#endif
+
 extern const struct elf_size_info _bfd_elfNN_size_info;
 
 #ifndef INCLUDED_TARGET_FILE
@@ -555,6 +559,7 @@ static const struct elf_backend_data elf
   elf_backend_ecoff_debug_swap,
   elf_backend_bfd_from_remote_memory,
   elf_backend_plt_sym_val,
+  elf_backend_link_order_error_handler,
   elf_backend_relplt_name,
   ELF_MACHINE_ALT1,
   ELF_MACHINE_ALT2,
--- bfd/libbfd-in.h.order	2004-07-28 10:50:39.000000000 -0700
+++ bfd/libbfd-in.h	2004-07-29 09:54:01.000000000 -0700
@@ -91,6 +91,7 @@ extern void *bfd_realloc
 extern void *bfd_zmalloc
   (bfd_size_type);
 
+extern void _bfd_default_error_handler (const char *s, ...);
 extern bfd_error_handler_type _bfd_error_handler;
 
 /* These routines allocate and free things on the BFD's objalloc.  */
--- bfd/libbfd.h.order	2004-07-28 10:50:39.000000000 -0700
+++ bfd/libbfd.h	2004-07-29 09:54:01.000000000 -0700
@@ -96,6 +96,7 @@
 extern void *bfd_zmalloc
   (bfd_size_type);
 
+extern void _bfd_default_error_handler (const char *s, ...);
 extern bfd_error_handler_type _bfd_error_handler;
 
 /* These routines allocate and free things on the BFD's objalloc.  */
